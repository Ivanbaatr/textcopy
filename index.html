<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>공강 필기 도우미</title>
    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 'Inter' 폰트 사용 */
        :root {
            font-family: 'Inter', sans-serif;
        }

        /* contenteditable div를 textarea처럼 보이게 스타일링 */
        #output-text {
            /* iOS 줌 방지 핵심 (16px 이상) */
            font-size: 1rem; /* 16px */
            
            /* 스크롤바 추가를 위해 max-height와 overflow-y 설정 (2줄 더 길게) */
            max-height: 470px; 
            overflow-y: auto; /* 내용이 넘칠 때 스크롤바 표시 */
            
            min-height: 200px;
            white-space: pre-wrap; /* 줄 바꿈 유지 */
            word-wrap: break-word;
            padding: 0.75rem;
            border: 1px solid #d1g-300;
            border-radius: 0.5rem;
            transition: all 150ms ease-in-out;
            font-family: monospace; /* 폰트 고정 */
        }
        
        /* placeholder 스타일 (첫 실행 시 안내 문구가 회색으로 보이도록) */
        #output-text[data-placeholder-active="true"] {
            color: #9ca3af; /* Gray-400 */
        }

        /* 시각적 포맷팅을 위한 CSS */
        #output-text u {
            text-decoration: underline;
        }
        #output-text strong {
            font-weight: 700; /* Bold */
        }
        /* 제목 (Title - H1) 스타일 */
        #output-text h1 {
            font-size: 1.875rem; /* 30px */
            font-weight: 800; /* Extra bold */
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.25rem;
            border-bottom: 2px solid #374151; /* Gray-700 */
        }
        /* 머리말 (Heading - H2) 스타일 */
        #output-text h2 {
            font-size: 1.5rem; /* 24px */
            font-weight: 700; /* Bold */
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
            padding-left: 0.5rem;
            border-left: 4px solid #4f46e5; /* Indigo-600 */
        }
        /* 부머리말 (Subheading - H3) 스타일 */
        #output-text h3 {
            font-size: 1.25rem; /* 20px */
            font-weight: 600; /* Semibold */
            margin-top: 1rem;
            margin-bottom: 0.25rem;
            color: #1f2937; /* Gray-800 */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 flex items-center justify-center">

    <div id="app" class="bg-white p-6 md:p-8 rounded-xl shadow-2xl w-full max-w-lg space-y-6">
        <!-- 제목 -->
        <h1 class="text-4xl font-extrabold text-gray-900 text-center border-b pb-3 mb-4">
            공강 필기 도우미
        </h1>
        
        <!-- WOL 사이트 열기 버튼 (가장 위에 위치) -->
        <button id="open-site-button"
            class="w-full px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-200 transform hover:scale-[1.01] active:scale-[0.99] mb-6">
            WOL 검색창 열기 (검색 후 내용 복사)
        </button>

        <!-- 2. 결과 영역 (필기 및 붙여넣기 영역) -->
        <div class="mt-0">
            <!-- 편집기 컨트롤 -->
            <div class="flex flex-nowrap space-x-2 mb-2 p-2 bg-gray-100 rounded-lg shadow-inner border border-gray-200 overflow-x-auto">
                <!-- 실행 취소 버튼 -->
                <button id="undo-button" title="실행 취소" disabled
                    class="p-2 rounded-md text-gray-600 hover:bg-gray-200 transition duration-150 disabled:text-gray-400 disabled:cursor-not-allowed flex-shrink-0">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-5 h-5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M9 15L3 9m0 0l6-6M3 9h12a6 6 0 010 12h-3"/>
                    </svg>
                </button>
                <!-- 다시 실행 버튼 -->
                <button id="redo-button" title="다시 실행" disabled
                    class="p-2 rounded-md text-gray-600 hover:bg-gray-200 transition duration-150 disabled:text-gray-400 disabled:cursor-not-allowed flex-shrink-0">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-5 h-5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15 9l6 6m0 0l-6 6m6-6H9a6 6 0 010-12h3"/>
                    </svg>
                </button>

                <span class="border-l border-gray-300 mx-1 flex-shrink-0"></span>
                
                <!-- 제목, 머리말, 부머리말 버튼 -->
                <button id="title-button" title="제목 (H1)"
                    class="p-2 rounded-md text-gray-600 hover:bg-gray-200 transition duration-150 font-extrabold text-lg flex-shrink-0">
                    H1
                </button>
                <button id="heading-button" title="머리말 (H2)"
                    class="p-2 rounded-md text-gray-600 hover:bg-gray-200 transition duration-150 font-bold flex-shrink-0">
                    H2
                </button>
                <button id="subheading-button" title="부머리말 (H3)"
                    class="p-2 rounded-md text-gray-600 hover:bg-gray-200 transition duration-150 font-semibold flex-shrink-0">
                    H3
                </button>

                <span class="border-l border-gray-300 mx-1 flex-shrink-0"></span>

                <!-- 기본 포맷 버튼 -->
                <button id="bold-button" title="굵게 (**텍스트**)"
                    class="p-2 rounded-md font-bold text-gray-600 hover:bg-gray-200 transition duration-150 flex-shrink-0">
                    B
                </button>
                <button id="underline-button" title="밑줄 (<u>텍스트</u>)"
                    class="p-2 rounded-md underline text-gray-600 hover:bg-gray-200 transition duration-150 font-semibold flex-shrink-0">
                    U
                </button>
            </div>
            
            <!-- contenteditable div (메인 필기 영역) -->
            <div id="output-text" contenteditable="true" data-placeholder-active="true"
                class="w-full border border-gray-300 rounded-lg text-gray-800 transition duration-150 shadow-inner">
                여기에 성구를 붙여넣으면 자동으로 정리됩니다.
            </div>
        </div>

        <!-- 3. 버튼 및 메시지 영역 -->
        <div class="pt-2 space-y-3">
            <div class="flex flex-col sm:flex-row gap-4">
                <!-- 복사하기 버튼 -->
                <button id="copy-button"
                    class="w-full sm:flex-1 px-6 py-3 bg-indigo-600 text-white font-semibold rounded-full shadow-lg hover:bg-indigo-700 transition duration-200 transform hover:scale-105 active:scale-95 disabled:bg-indigo-300 disabled:cursor-not-allowed">
                    복사하기
                </button>
                <!-- 모두 지우기 버튼 -->
                <button id="clear-button"
                    class="w-full sm:flex-1 px-6 py-3 border border-gray-300 bg-gray-50 text-gray-700 font-semibold rounded-full shadow-md hover:bg-gray-100 transition duration-200 transform hover:scale-105 active:scale-95">
                    모두 지우기
                </button>
            </div>
            <span id="message" class="block text-center text-sm font-medium text-green-600 opacity-0 transition duration-300"></span>
        </div>

        <!-- 4. 버전 표시 영역 -->
        <div class="text-right pt-2">
            <span class="text-xs text-gray-400">v1.1.6 (Placeholder fix)</span>
        </div>

    </div>

    <script>
        // --- 1. DOM 요소 참조 ---
        const outputTextarea = document.getElementById('output-text');
        const copyButton = document.getElementById('copy-button');
        const clearButton = document.getElementById('clear-button'); 
        const messageSpan = document.getElementById('message');
        const undoButton = document.getElementById('undo-button');
        const redoButton = document.getElementById('redo-button');
        const openSiteButton = document.getElementById('open-site-button');
        
        const editingTarget = outputTextarea;
        const apiKey = "" 

        // 성경의 책 이름 전체 목록
        const BIBLE_BOOKS = [
            '창세기', '출애굽기', '레위기', '민수기', '신명기', '여호수아', '사사기', '룻기', 
            '사무엘상', '사무엘하', '열왕기상', '열왕기하', '역대기상', '역대기하', '에스라', '느헤미야', 
            '에스더', '욥기', '시편', '잠언', '전도서', '솔로몬의 노래', '이사야', '예레미야', '예레미야 애가', 
            '에스겔', '다니엘', '호세아', '요엘', '아모스', '오바댜', '요나', '미가', '나훔', 
            '하박국', '스바냐', '학개', '스가랴', '말라기', '마태복음', '마가복음', '누가복음', 
            '요한복음', '사도행전', '로마서', '고린도 전서', '고린도 후서', '갈라디아서', '에베소서', 
            '빌립보서', '골로새서', '데살로니가 전서', '데살로니가 후서', '디모데 전서', '디모데 후서', 
            '디도서', '빌레몬서', '히브리서', '야고보서', '베드로 전서', '베드로 후서', 
            '요한 1서', '요한 2서', '요한 3서', '유다서', '요한 계시록'
        ];

        // iOS 서식 유지를 위한 인라인 스타일 매핑 (copyToClipboard에서 사용)
        const RICH_TEXT_STYLES = {
            'H1': 'font-size: 1.5rem; font-weight: 800; line-height: 1.3; margin-top: 1.5rem; margin-bottom: 0.75rem; border-bottom: 2px solid #374151; display: block; border-left: none; padding-left: 0;',
            'H2': 'font-size: 1.25rem; font-weight: 700; line-height: 1.4; margin-top: 1.25rem; margin-bottom: 0.5rem; border-left: 4px solid #4f46e5; padding-left: 0.5rem; display: block;',
            'H3': 'font-size: 1.125rem; font-weight: 600; line-height: 1.5; margin-top: 1rem; margin-bottom: 0.25rem; color: #1f2937; display: block; border-left: none; padding-left: 0;',
            'STRONG': 'font-weight: bold;',
            'U': 'text-decoration: underline;',
        };


        // --- 2. 텍스트 편집기 (Undo/Redo) 상태 관리 ---
        const MAX_HISTORY_SIZE = 50;
        let historyStack = ['여기에 성구를 붙여넣으면 자동으로 정리됩니다.']; // 초기 상태 변경
        let historyIndex = 0;
        let isRestoring = false;
        const PLACEHOLDER_TEXT = '여기에 성구를 붙여넣으면 자동으로 정리됩니다.';
        
        // --- 3. Conversion Functions ---

        /**
         * Raw Text (Markdown: #, ##, **)을 HTML (<h1>, <h2>, <strong>)로 변환합니다.
         */
        function toRenderableHTML(rawText) {
            if (!rawText) return '';
            let html = rawText;
            
            // 1. Markdown Headers를 HTML 태그로 변환합니다.
            html = html.replace(/^#\s([^\n]+)/gm, '<h1>$1</h1>');
            html = html.replace(/^##\s([^\n]+)/gm, '<h2>$1</h2>');
            html = html.replace(/^###\s([^\n]+)/gm, '<h3>$1</h3>');
            
            // 2. Inline Markdown을 HTML로 변환합니다.
            html = html.replace(/\*\*(.+?)\*\*/gs, '<strong>$1</strong>'); // Bold

            // 3. Raw line breaks를 HTML line breaks로 변환합니다.
            html = html.replace(/\n/g, '<br>');
            
            return html;
        }

        /**
         * HTML Content (editor)를 Markdown/Raw Text (#, ##, **)로 변환합니다.
         */
        function toRawText(htmlContent) {
            if (!htmlContent) return '';
            let raw = htmlContent;
            
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = raw;
            raw = tempDiv.innerHTML;

            raw = raw.replace(/<br[^>]*>/gis, '\n'); 

            // A. Block Element Conversion (H1, H2, H3 to Markdown Headers)
            raw = raw.replace(/<h1[^>]*>(.*?)<\/h1>/gis, '\n\n# $1\n\n'); 
            raw = raw.replace(/<h2[^>]*>(.*?)<\/h2>/gis, '\n\n## $1\n\n'); 
            raw = raw.replace(/<h3[^>]*>(.*?)<\/h3>/gis, '\n\n### $1\n\n'); 
            
            // B. Inline Element Conversion (Bold)
            raw = raw.replace(/<strong[^>]*>(.*?)<\/strong>/gis, '**$1**');
            raw = raw.replace(/<b[^>]*>(.*?)<\/b>/gis, '**$1**'); 

            // C. Line Break and Cleanup
            raw = raw.replace(/<div[^>]*>(.*?)<\/div>/gis, '$1\n') 
                     .replace(/<p[^>]*>(.*?)<\/p>/gis, '$1\n')
                     .replace(/<[^>]+>/g, '')  
                     .replace(/\n\s*\n\s*\n/g, '\n\n') 
                     .trim();
            
            return raw; 
        }

        // --- 4. History Management ---

        function saveState() {
            if (isRestoring) return;

            const currentStateRaw = toRawText(editingTarget.innerHTML);
            const lastState = historyStack[historyIndex];

            // Placeholder 상태 관리
            togglePlaceholder(currentStateRaw);

            // Placeholder 텍스트는 히스토리에 저장하지 않음 (실제 내용만 저장)
            const contentToSave = currentStateRaw === PLACEHOLDER_TEXT ? '' : currentStateRaw;

            if (contentToSave !== lastState) {
                if (historyIndex < historyStack.length - 1) {
                    historyStack = historyStack.slice(0, historyIndex + 1);
                }

                if (historyStack.length >= MAX_HISTORY_SIZE) {
                    historyStack.shift(); 
                } else {
                    historyIndex++;
                }
                historyStack[historyIndex] = contentToSave;
            }
            updateHistoryButtons();
            updateCopyButtonStatus(contentToSave);
        }
        
        function updateHistoryButtons() {
            // Placeholder 상태일 때는 undo/redo 비활성화
            undoButton.disabled = historyIndex === 0 || editingTarget.getAttribute('data-placeholder-active') === 'true';
            redoButton.disabled = historyIndex === historyStack.length - 1 || editingTarget.getAttribute('data-placeholder-active') === 'true';
        }

        function restoreState(index) {
            isRestoring = true;
            historyIndex = index;
            const restoredText = historyStack[historyIndex];
            
            // Placeholder 처리
            if (restoredText === '' && index === 0) {
                 editingTarget.innerHTML = PLACEHOLDER_TEXT;
            } else {
                 editingTarget.innerHTML = toRenderableHTML(restoredText);
            }
            togglePlaceholder(toRawText(editingTarget.innerHTML));

            isRestoring = false;
            updateHistoryButtons();
            updateCopyButtonStatus(restoredText);
            editingTarget.focus();
        }

        function undo() {
            if (historyIndex > 0) {
                restoreState(historyIndex - 1);
            }
        }

        function redo() {
            if (historyIndex < historyStack.length - 1) {
                restoreState(historyIndex + 1);
            }
        }

        // Placeholder 토글 로직
        function togglePlaceholder(currentRawText) {
            const isActive = currentRawText.trim() === PLACEHOLDER_TEXT || currentRawText.trim() === '';
            editingTarget.setAttribute('data-placeholder-active', isActive ? 'true' : 'false');
            
            if (isActive && currentRawText.trim() !== PLACEHOLDER_TEXT) {
                // 이 상황은 보통 clearAllText()에서만 발생하며,
                // placeholder가 없는데 active가 true로 설정되려는 경우를 방지
                editingTarget.innerHTML = PLACEHOLDER_TEXT;
            }
            updateHistoryButtons();
        }

        // --- 5. Core Cleaning Logic ---

        function applyCleaningRules(rawText) {
            if (!rawText) return '';

            // 1. 연속된 '+' 문자 제거
            rawText = rawText.replace(/\++/g, '');
            
            // 2. '신세계역 성경 (연구용)' 문구를 찾아 ')' 하나로 치환 및 주변 문자 정리
            const phraseToTarget = "신세계역 성경 (연구용)";
            const escapedPhrase = phraseToTarget.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const phraseRegex = new RegExp(`[\\s\\r\\n]*${escapedPhrase}[\\s\\r\\n]*.{0,2}`, 'g');
            rawText = rawText.replace(phraseRegex, ')');

            // 3. 숫자, 쉼표, 공백, 숫자 패턴에서 공백 제거 (예: 1, 000 -> 1,000)
            rawText = rawText.replace(/(\d+),\s+(\d+)/g, '$1,$2');
            
            const BIBLE_BOOKS_REGEX_STRING = BIBLE_BOOKS.map(name => name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');

            // 4. 줄 바꿈(\n)이나 텍스트 시작(^) 바로 뒤에 성경 책 이름이 오면 그 앞에 '(' 삽입
            const bookStartRegex = new RegExp(`(^|\\n)(${BIBLE_BOOKS_REGEX_STRING})`, 'g');
            rawText = rawText.replace(bookStartRegex, '$1($2');

            // 5. 단일 별표 문자('*') 제거 (강조된 별표(**) 보존)
            let cleanedText = rawText.replace(/\*\*/g, '@@@BOLD_TEMP@@@');
            cleanedText = cleanedText.replace(/\*/g, '');
            rawText = cleanedText.replace(/@@@BOLD_TEMP@@@/g, '**');

            return rawText.trim();
        }
        
        // --- 6. Core Processing & Utility ---
        
        /**
         * @description 필기창에 직접 붙여넣기를 처리하고, 붙여넣기된 텍스트를 정리하여 삽입합니다.
         */
        function handlePaste(e) {
            e.preventDefault(); // 기본 붙여넣기 동작 막기 (지저분한 서식 방지)

            // 1. 클립보드에서 순수 텍스트 가져오기
            const pastedText = (e.clipboardData || window.clipboardData).getData('text/plain');

            if (!pastedText) return;

            // 2. Placeholder 상태일 경우 지우기
            const currentRawText = toRawText(editingTarget.innerHTML);
            if (currentRawText.trim() === PLACEHOLDER_TEXT) {
                editingTarget.innerHTML = '';
            }

            // 3. 텍스트 정리
            const cleanedText = applyCleaningRules(pastedText);

            // 4. 현재 커서 위치에 정리된 텍스트 삽입
            document.execCommand('insertText', false, cleanedText);
            
            // 5. 히스토리 저장
            saveState();

            // 붙여넣은 후 스크롤을 맨 아래로 이동
            editingTarget.scrollTop = editingTarget.scrollHeight;
        }

        function updateCopyButtonStatus(text) {
             const finalContent = text.trim() === PLACEHOLDER_TEXT ? '' : text;
             if (finalContent.length > 0) {
                copyButton.disabled = false;
            } else {
                copyButton.disabled = true;
            }
        }

        function applyFormat(command) {
            editingTarget.focus();
            // Placeholder 상태일 경우 포맷팅 적용 막기
            if (toRawText(editingTarget.innerHTML).trim() === PLACEHOLDER_TEXT) return;
            
            document.execCommand(command, false, null);
            saveState(); 
        }

        function applyFormatBlock(tag) {
            editingTarget.focus();
            // Placeholder 상태일 경우 포맷팅 적용 막기
            if (toRawText(editingTarget.innerHTML).trim() === PLACEHOLDER_TEXT) return;
            
            document.execCommand('formatBlock', false, tag);
            saveState(); 
        }

        function clearAllText() {
            editingTarget.innerHTML = PLACEHOLDER_TEXT;
            saveState(); // 초기 상태 저장
            togglePlaceholder(PLACEHOLDER_TEXT);
            
            messageSpan.classList.remove('opacity-100');
            messageSpan.classList.add('opacity-0');
            messageSpan.textContent = '';
        }

        /**
         * @description iOS/iPadOS에서 서식이 유지된 Rich Text 복사를 위해 모든 서식을 인라인 스타일로 변환하여 클립보드에 복사합니다.
         */
        function copyToClipboard() {
            const contentDiv = editingTarget;
            
            const rawContent = toRawText(contentDiv.innerHTML).trim();
            if (rawContent === "" || rawContent === PLACEHOLDER_TEXT) {
                return; 
            }
            
            try {
                // 1. 임시 Div 설정: 인라인 스타일 복사를 위해 contenteditable 속성을 부여합니다.
                const tempDiv = document.createElement('div');
                tempDiv.style.cssText = 'font-family: Inter, sans-serif; white-space: pre-wrap; font-size: 1rem;'; 
                tempDiv.setAttribute('contenteditable', 'true');
                
                // 2. HTML을 iOS 호환 구조로 변환합니다. (H 태그를 <p>로 변경)
                let contentHTML = contentDiv.innerHTML;
                
                // H1/H2/H3 태그를 인라인 스타일이 적용된 <p> 태그로 변환
                contentHTML = contentHTML.replace(/<h1[^>]*>(.*?)<\/h1>/gis, (match, content) => {
                    return `<p style="${RICH_TEXT_STYLES['H1']}">${content}</p>`;
                });
                contentHTML = contentHTML.replace(/<h2[^>]*>(.*?)<\/h2>/gis, (match, content) => {
                    return `<p style="${RICH_TEXT_STYLES['H2']}">${content}</p>`;
                });
                contentHTML = contentHTML.replace(/<h3[^>]*>(.*?)<\/h3>/gis, (match, content) => {
                    return `<p style="${RICH_TEXT_STYLES['H3']}">${content}</p>`;
                });

                // STRONG과 U 태그를 인라인 스타일이 적용된 <span> 태그로 변환
                contentHTML = contentHTML.replace(/<strong[^>]*>(.*?)<\/strong>/gis, `<span style="${RICH_TEXT_STYLES['STRONG']}">$1</span>`);
                contentHTML = contentHTML.replace(/<b[^>]*>(.*?)<\/b>/gis, `<span style="${RICH_TEXT_STYLES['STRONG']}">$1</span>`);
                contentHTML = contentHTML.replace(/<u[^>]*>(.*?)<\/u>/gis, `<span style="${RICH_TEXT_STYLES['U']}">$1</span>`);

                // <br> 태그에 닫는 슬래시 추가
                contentHTML = contentHTML.replace(/<br>/g, '<br />');

                tempDiv.innerHTML = contentHTML;

                // 3. 임시 Div를 화면 밖으로 이동 후 삽입합니다.
                tempDiv.style.position = 'absolute';
                tempDiv.style.left = '-9999px';
                
                document.body.appendChild(tempDiv);
                
                // 4. 프로그램적으로 선택 및 복사 실행
                const range = document.createRange();
                range.selectNodeContents(tempDiv);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);

                document.execCommand('copy');
                
                // 5. 정리
                selection.removeAllRanges();
                document.body.removeChild(tempDiv);
                
                // 성공 메시지 표시
                messageSpan.textContent = '복사 완료! (iOS 메모장 최적화 완료)';
                messageSpan.classList.remove('opacity-0', 'text-red-600');
                messageSpan.classList.add('opacity-100', 'text-green-600');

                setTimeout(() => {
                    messageSpan.classList.remove('opacity-100');
                    messageSpan.classList.add('opacity-0');
                    messageSpan.textContent = '';
                }, 2000);

            } catch (err) {
                console.error('클립보드 복사 실패:', err);
                messageSpan.textContent = '복사 실패: 콘솔 확인';
                messageSpan.classList.remove('opacity-0', 'text-green-600');
                messageSpan.classList.add('opacity-100', 'text-red-600');
            }
        }

        function initializeState() {
            // 초기 상태를 Placeholder 텍스트로 설정하고 히스토리 저장
            clearAllText(); 
        }

        // --- 7. 이벤트 리스너 설정 ---

        // WOL 사이트 열기 및 주요 버튼
        openSiteButton.addEventListener('click', () => {
            window.open('https://wol.jw.org/ko/wol/h/r8/lp-ko', 'wol_tab');
        });
        
        copyButton.addEventListener('click', copyToClipboard);
        clearButton.addEventListener('click', clearAllText); 
        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);

        // 핵심 기능: 필기창 (output-text)에 직접 붙여넣기 감지 및 처리
        editingTarget.addEventListener('paste', handlePaste);
        
        /**
         * @BUG_FIX: 입력 시 Placeholder 텍스트가 함께 입력되는 문제 수정.
         * 입력 발생 시, Placeholder 텍스트가 남아있으면 제거하고 커서를 재설정합니다.
         */
        editingTarget.addEventListener('input', () => {
            const wasPlaceholderActive = editingTarget.getAttribute('data-placeholder-active') === 'true';
            const currentRawText = toRawText(editingTarget.innerHTML).trim();
            
            // 1. 사용자가 placeholder 위에 바로 타이핑을 시작하여 placeholder 텍스트가 남아있는 경우 처리
            if (wasPlaceholderActive && currentRawText.includes(PLACEHOLDER_TEXT) && currentRawText !== PLACEHOLDER_TEXT) {
                
                // placeholder 텍스트를 제거하고 실제 입력 내용만 남깁니다.
                // NOTE: toRawText()가 이미 줄바꿈 등을 처리하여 raw 텍스트를 가져옴
                const newText = currentRawText.replace(PLACEHOLDER_TEXT, '').trim();

                // 텍스트를 DOM에 다시 설정하여 placeholder 잔여물을 완전히 지우고 커서를 맨 뒤로 옮깁니다.
                isRestoring = true;
                editingTarget.innerHTML = newText;
                
                // 커서를 맨 뒤로 이동 (이것이 핵심 - 텍스트 입력 후 커서 위치 유지)
                const range = document.createRange();
                const sel = window.getSelection();
                
                // 텍스트 노드가 존재하면 그 노드의 끝으로 이동
                if (editingTarget.firstChild && editingTarget.firstChild.nodeType === 3) {
                    range.setStart(editingTarget.firstChild, editingTarget.firstChild.length);
                } else {
                    range.selectNodeContents(editingTarget);
                }
                range.collapse(false);
                sel.removeAllRanges();
                sel.addRange(range);
                
                isRestoring = false;
                
                // placeholder active 속성 업데이트
                togglePlaceholder(newText); 
            }
            
            // 2. 상태 저장 (히스토리 업데이트 및 복사 버튼 상태 업데이트)
            saveState();
        });


        // 사용자가 포커스했을 때 placeholder 텍스트가 있으면 지우기
        editingTarget.addEventListener('focus', () => {
            const currentRawText = toRawText(editingTarget.innerHTML).trim();
            if (currentRawText === PLACEHOLDER_TEXT) {
                editingTarget.innerHTML = '';
                togglePlaceholder('');
            }
        });

        // 사용자가 포커스를 잃었을 때 내용이 없으면 placeholder 복원
        editingTarget.addEventListener('blur', () => {
            if (toRawText(editingTarget.innerHTML).trim() === '') {
                editingTarget.innerHTML = PLACEHOLDER_TEXT;
                togglePlaceholder(PLACEHOLDER_TEXT);
            }
        });


        // --- 포맷팅 버튼 그룹화 ---
        
        // 구조 포맷 (H1, H2, H3)
        const structureMap = {
            'title-button': '<h1>',
            'heading-button': '<h2>',
            'subheading-button': '<h3>',
        };

        Object.entries(structureMap).forEach(([id, tag]) => {
            document.getElementById(id).addEventListener('click', () => applyFormatBlock(tag));
        });

        // 기본 포맷 (Bold, Underline)
        const basicFormatMap = {
            'bold-button': 'bold',
            'underline-button': 'underline',
        };

        Object.entries(basicFormatMap).forEach(([id, command]) => {
            document.getElementById(id).addEventListener('click', () => applyFormat(command));
        });
        // -------------------------

        // 초기 상태 설정
        initializeState(); 

    </script>
</body>
</html>
