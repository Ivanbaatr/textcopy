<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>공강 필기 도우미</title>
    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 'Inter' 폰트 사용 */
        :root {
            font-family: 'Inter', sans-serif;
        }
        /* contenteditable div를 textarea처럼 보이게 스타일링 */
        #output-text {
            /* 스크롤바 추가를 위해 max-height와 overflow-y 설정 */
            max-height: 400px; /* 최대 높이를 400px로 설정 */
            overflow-y: auto; /* 내용이 넘칠 때 스크롤바 표시 */

            min-height: 200px;
            white-space: pre-wrap; /* 줄 바꿈 유지 */
            word-wrap: break-word;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            transition: all 150ms ease-in-out;
            font-family: monospace; /* 폰트 고정 */
        }
        /* 시각적 포맷팅을 위한 CSS */
        #output-text u {
            text-decoration: underline;
        }
        #output-text strong {
            font-weight: 700; /* Bold */
        }
        /* 제목 (Title - H1) 스타일 */
        #output-text h1 {
            font-size: 1.875rem; /* 30px */
            font-weight: 800; /* Extra bold */
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.25rem;
            border-bottom: 2px solid #374151; /* Gray-700 */
        }
        /* 머리말 (Heading - H2) 스타일 */
        #output-text h2 {
            font-size: 1.5rem; /* 24px */
            font-weight: 700; /* Bold */
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
            padding-left: 0.5rem;
            border-left: 4px solid #4f46e5; /* Indigo-600 */
        }
        /* 부머리말 (Subheading - H3) 스타일 */
        #output-text h3 {
            font-size: 1.25rem; /* 20px */
            font-weight: 600; /* Semibold */
            margin-top: 1rem;
            margin-bottom: 0.25rem;
            color: #1f2937; /* Gray-800 */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 flex items-center justify-center">

    <div id="app" class="bg-white p-6 md:p-8 rounded-xl shadow-2xl w-full max-w-lg space-y-6">
        <!-- 제목 크기: text-4xl로 변경하여 가독성 높임 -->
        <h1 class="text-4xl font-extrabold text-gray-900 text-center border-b pb-3 mb-4">
            공강 필기 도우미
        </h1>
        
        <!-- 고정된 규칙 안내 (숨김 유지) -->
        <div class="p-3 bg-red-50 border-l-4 border-red-500 rounded-lg shadow-sm hidden">
            <p class="text-sm font-semibold text-red-700">
                자동 제거 및 치환 규칙 (WOL 성경 텍스트에 최적화):
            </p>
            <ul class="text-sm text-gray-700 list-disc list-inside ml-2 mt-1">
                <li>**연속된 '+'** 문자 제거</li>
                <li>**'신세계역 성경 (연구용)'** 문구를 **')'** 하나로 치환 (주변 공백 정리 및 **치환 후 문자 2개 추가 제거**)</li>
                <li>**"숫자, 공백, 숫자"** 패턴에서 공백 제거 (예: `1, 234` → `1,234`)</li>
                <li>**줄 시작에 오는 성경 책 이름 앞**에 **'('** 삽입</li>
                <li>**단일 별표('*')** 제거 (원치 않는 기울임꼴 변환 방지)</li>
            </ul>
        </div>
        
        <!-- 1. 입력 영역 -->
        <div>
            <!-- WOL 사이트 열기 버튼 (새로 추가) -->
            <button id="open-site-button"
                class="w-full mb-4 px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-200 transform hover:scale-[1.01] active:scale-[0.99]">
                WOL 검색창 열기 (검색 후 내용 복사)
            </button>

            <!-- 라벨 크기: text-sm -> text-base 로 변경 -->
            <label for="input-text" class="block text-base font-medium text-gray-700 mb-2">
                성구 (여기에 붙여넣으세요) - **붙여넣기 시 자동 정리됩니다.**
            </label>
            
            <!-- rows="3"으로 변경됨 -->
            <textarea id="input-text" rows="3" placeholder="워치타워 온라인 라이브러리에서 성구를 복사하여 여기에 붙여 넣으세요."
                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 shadow-inner"></textarea>
            
            <!-- 처리 버튼 (붙여넣기 자동화로 인해 이제 수동 처리 또는 입력 후 처리용) -->
            <button id="process-button"
                class="w-full mt-3 px-6 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition duration-200 transform hover:scale-[1.01] active:scale-[0.99] disabled:bg-green-300 disabled:cursor-not-allowed">
                아래에 추가하기 (수동 처리)
            </button>
        </div>

        <!-- 2. 결과 영역 -->
        <div class="mt-6">
            <!-- 라벨 크기: text-sm -> text-base 로 변경 -->
            <label for="output-text" class="block text-base font-medium text-gray-700 mb-2">
                필기창 (여기에 텍스트를 작성하세요)
            </label>
            
            <!-- 편집기 컨트롤 -->
            <div class="flex flex-wrap space-x-2 mb-2 p-2 bg-gray-100 rounded-lg shadow-inner border border-gray-200">
                <!-- 실행 취소 버튼 (더 큰 화살표 아이콘 사용) -->
                <button id="undo-button" title="실행 취소" disabled
                    class="p-2 rounded-md text-gray-600 hover:bg-gray-200 transition duration-150 disabled:text-gray-400 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-5 h-5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M9 15L3 9m0 0l6-6M3 9h12a6 6 0 010 12h-3"/>
                    </svg>
                </button>
                <!-- 다시 실행 버튼 (더 큰 화살표 아이콘 사용) -->
                <button id="redo-button" title="다시 실행" disabled
                    class="p-2 rounded-md text-gray-600 hover:bg-gray-200 transition duration-150 disabled:text-gray-400 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-5 h-5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15 9l6 6m0 0l-6 6m6-6H9a6 6 0 010-12h3"/>
                    </svg>
                </button>

                <span class="border-l border-gray-300 mx-1"></span>
                
                <!-- 제목, 머리말, 부머리말 버튼 추가 (터치 영역 p-2로 확대) -->
                <button id="title-button" title="제목 (H1)"
                    class="p-2 rounded-md text-gray-600 hover:bg-gray-200 transition duration-150 font-extrabold text-lg">
                    H1
                </button>
                <button id="heading-button" title="머리말 (H2)"
                    class="p-2 rounded-md text-gray-600 hover:bg-gray-200 transition duration-150 font-bold">
                    H2
                </button>
                <button id="subheading-button" title="부머리말 (H3)"
                    class="p-2 rounded-md text-gray-600 hover:bg-gray-200 transition duration-150 font-semibold">
                    H3
                </button>

                <span class="border-l border-gray-300 mx-1"></span>

                <!-- 기본 포맷 버튼 (터치 영역 p-2로 확대) -->
                <button id="bold-button" title="굵게 (**텍스트**)"
                    class="p-2 rounded-md font-bold text-gray-600 hover:bg-gray-200 transition duration-150">
                    B
                </button>
                <!-- 기울임꼴 버튼이 제거되었습니다. -->
                <button id="underline-button" title="밑줄 (<u>텍스트</u>)"
                    class="p-2 rounded-md underline text-gray-600 hover:bg-gray-200 transition duration-150 font-semibold">
                    U
                </button>
            </div>
            
            <!-- contenteditable div -->
            <div id="output-text" contenteditable="true" 
                class="w-full border border-gray-300 rounded-lg text-gray-800 transition duration-150 shadow-inner">
            </div>
        </div>

        <!-- 3. 버튼 및 메시지 영역 -->
        <div class="pt-2 space-y-3">
            <div class="flex flex-col sm:flex-row gap-4">
                <!-- 모두 지우기 버튼 -->
                <button id="clear-button"
                    class="w-full sm:flex-1 px-6 py-3 border border-gray-300 bg-gray-50 text-gray-700 font-semibold rounded-full shadow-md hover:bg-gray-100 transition duration-200 transform hover:scale-105 active:scale-95">
                    모두 지우기
                </button>
                <!-- 복사하기 버튼 -->
                <button id="copy-button"
                    class="w-full sm:flex-1 px-6 py-3 bg-indigo-600 text-white font-semibold rounded-full shadow-lg hover:bg-indigo-700 transition duration-200 transform hover:scale-105 active:scale-95 disabled:bg-indigo-300 disabled:cursor-not-allowed">
                    복사하기
                </button>
            </div>
            <span id="message" class="block text-center text-sm font-medium text-green-600 opacity-0 transition duration-300"></span>
        </div>

        <!-- 4. 버전 표시 영역 (새로 추가됨) -->
        <div class="text-right pt-2">
            <span class="text-xs text-gray-400">v1.0.1 (Optimized)</span>
        </div>

    </div>

    <script>
        // --- 1. DOM 요소 참조 ---
        const inputTextarea = document.getElementById('input-text');
        const outputTextarea = document.getElementById('output-text');
        const copyButton = document.getElementById('copy-button');
        const clearButton = document.getElementById('clear-button'); 
        const processButton = document.getElementById('process-button'); 
        const messageSpan = document.getElementById('message');
        const undoButton = document.getElementById('undo-button');
        const redoButton = document.getElementById('redo-button');
        const openSiteButton = document.getElementById('open-site-button');
        
        const editingTarget = outputTextarea;
        const apiKey = "" 

        // 성경의 책 이름 전체 목록
        const BIBLE_BOOKS = [
            '창세기', '출애굽기', '레위기', '민수기', '신명기', '여호수아', '사사기', '룻기', 
            '사무엘상', '사무엘하', '열왕기상', '열왕기하', '역대기상', '역대기하', '에스라', '느헤미야', 
            '에스더', '욥기', '시편', '잠언', '전도서', '솔로몬의 노래', '이사야', '예레미야', '예레미야 애가', 
            '에스겔', '다니엘', '호세아', '요엘', '아모스', '오바댜', '요나', '미가', '나훔', 
            '하박국', '스바냐', '학개', '스가랴', '말라기', '마태복음', '마가복음', '누가복음', 
            '요한복음', '사도행전', '로마서', '고린도 전서', '고린도 후서', '갈라디아서', '에베소서', 
            '빌립보서', '골로새서', '데살로니가 전서', '데살로니가 후서', '디모데 전서', '디모데 후서', 
            '디도서', '빌레몬서', '히브리서', '야고보서', '베드로 전서', '베드로 후서', 
            '요한 1서', '요한 2서', '요한 3서', '유다서', '요한 계시록'
        ];

        // iOS 서식 유지를 위한 인라인 스타일 매핑 (copyToClipboard에서 사용)
        const RICH_TEXT_STYLES = {
            'H1': 'font-size: 1.875rem; font-weight: 800; line-height: 1.3; margin-top: 1.5rem; margin-bottom: 0.75rem; border-bottom: 2px solid #374151;',
            'H2': 'font-size: 1.5rem; font-weight: 700; line-height: 1.4; margin-top: 1.25rem; margin-bottom: 0.5rem; border-left: 4px solid #4f46e5; padding-left: 0.5rem;',
            'H3': 'font-size: 1.25rem; font-weight: 600; line-height: 1.5; margin-top: 1rem; margin-bottom: 0.25rem; color: #1f2937;',
            'STRONG': 'font-weight: bold;',
            'B': 'font-weight: bold;',
            // 기울기 관련 스타일 제거됨
            'U': 'text-decoration: underline;',
        };


        // --- 2. 텍스트 편집기 (Undo/Redo) 상태 관리 ---
        const MAX_HISTORY_SIZE = 50;
        let historyStack = ['']; 
        let historyIndex = 0;
        let isRestoring = false;
        
        // --- 3. Conversion Functions ---

        /**
         * Raw Text (Markdown: #, ##, **, *)을 HTML (<h1>, <h2>, <strong>)로 변환합니다.
         * * 기울임꼴 마크다운 변환 로직 제거됨.
         */
        function toRenderableHTML(rawText) {
            if (!rawText) return '';
            let html = rawText;
            
            // 1. Markdown Headers를 HTML 태그로 변환합니다.
            html = html.replace(/^#\s([^\n]+)/gm, '<h1>$1</h1>');
            html = html.replace(/^##\s([^\n]+)/gm, '<h2>$1</h2>');
            html = html.replace(/^###\s([^\n]+)/gm, '<h3>$1</h3>');
            
            // 2. Inline Markdown을 HTML로 변환합니다.
            html = html.replace(/\*\*(.+?)\*\*/gs, '<strong>$1</strong>'); // Bold
            // 기울임꼴 변환 로직 제거됨: html.replace(/\*(.+?)\*/gs, '<em>$1</em>');

            // 3. Raw line breaks를 HTML line breaks로 변환합니다.
            html = html.replace(/\n/g, '<br>');
            
            return html;
        }

        /**
         * HTML Content (editor)를 Markdown/Raw Text (#, ##, **, *)로 변환합니다.
         * * 기울임꼴 HTML 태그 변환 로직 제거됨.
         */
        function toRawText(htmlContent) {
            if (!htmlContent) return '';
            let raw = htmlContent;
            
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = raw;
            raw = tempDiv.innerHTML;

            raw = raw.replace(/<br[^>]*>/gis, '\n'); 

            // A. Block Element Conversion (H1, H2, H3 to Markdown Headers)
            raw = raw.replace(/<h1[^>]*>(.*?)<\/h1>/gis, '\n\n# $1\n\n'); 
            raw = raw.replace(/<h2[^>]*>(.*?)<\/h2>/gis, '\n\n## $1\n\n'); 
            raw = raw.replace(/<h3[^>]*>(.*?)<\/h3>/gis, '\n\n### $1\n\n'); 
            
            // B. Inline Element Conversion (Bold)
            raw = raw.replace(/<strong[^>]*>(.*?)<\/strong>/gis, '**$1**');
            raw = raw.replace(/<b[^>]*>(.*?)<\/b>/gis, '**$1**'); 
            // 기울임꼴 변환 로직 제거됨: raw = raw.replace(/<em[^>]*>(.*?)<\/em>/gis, '*$1*');
            // 기울임꼴 변환 로직 제거됨: raw = raw.replace(/<i[^>]*>(.*?)<\/i>/gis, '*$1*'); 

            // C. Line Break and Cleanup
            raw = raw.replace(/<div[^>]*>(.*?)<\/div>/gis, '$1\n') 
                     .replace(/<p[^>]*>(.*?)<\/p>/gis, '$1\n')
                     .replace(/<[^>]+>/g, '')  
                     .replace(/\n\s*\n\s*\n/g, '\n\n') 
                     .trim();
            
            return raw; 
        }

        // --- 4. History Management ---

        function saveState() {
            if (isRestoring) return;

            const currentStateRaw = toRawText(editingTarget.innerHTML);
            const lastState = historyStack[historyIndex];

            if (currentStateRaw !== lastState) {
                if (historyIndex < historyStack.length - 1) {
                    historyStack = historyStack.slice(0, historyIndex + 1);
                }

                if (historyStack.length >= MAX_HISTORY_SIZE) {
                    historyStack.shift(); 
                } else {
                    historyIndex++;
                }
                historyStack[historyIndex] = currentStateRaw;
            }
            updateHistoryButtons();
            updateCopyButtonStatus(currentStateRaw);
        }
        
        function updateHistoryButtons() {
            undoButton.disabled = historyIndex === 0;
            redoButton.disabled = historyIndex === historyStack.length - 1;
        }

        function undo() {
            if (historyIndex > 0) {
                isRestoring = true;
                historyIndex--;
                editingTarget.innerHTML = toRenderableHTML(historyStack[historyIndex]);
                isRestoring = false;
                updateHistoryButtons();
                updateCopyButtonStatus(historyStack[historyIndex]);
                editingTarget.focus();
            }
        }

        function redo() {
            if (historyIndex < historyStack.length - 1) {
                isRestoring = true;
                historyIndex++;
                editingTarget.innerHTML = toRenderableHTML(historyStack[historyIndex]);
                isRestoring = false;
                updateHistoryButtons();
                updateCopyButtonStatus(historyStack[historyIndex]);
                editingTarget.focus();
            }
        }

        // --- 5. Core Cleaning Logic ---

        function applyCleaningRules(rawText) {
            if (!rawText) return '';

            // 1. 연속된 '+' 문자 제거
            rawText = rawText.replace(/\++/g, '');
            
            // 2. '신세계역 성경 (연구용)' 문구를 찾아 ')' 하나로 치환 및 주변 문자 정리
            const phraseToTarget = "신세계역 성경 (연구용)";
            const escapedPhrase = phraseToTarget.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const phraseRegex = new RegExp(`[\\s\\r\\n]*${escapedPhrase}[\\s\\r\\n]*.{0,2}`, 'g');
            rawText = rawText.replace(phraseRegex, ')');

            // 3. 숫자, 쉼표, 공백, 숫자 패턴에서 공백 제거 (예: 1, 000 -> 1,000)
            rawText = rawText.replace(/(\d+),\s+(\d+)/g, '$1,$2');
            
            const BIBLE_BOOKS_REGEX_STRING = BIBLE_BOOKS.map(name => name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');

            // 4. 줄 바꿈(\n)이나 텍스트 시작(^) 바로 뒤에 성경 책 이름이 오면 그 앞에 '(' 삽입
            const bookStartRegex = new RegExp(`(^|\\n)(${BIBLE_BOOKS_REGEX_STRING})`, 'g');
            rawText = rawText.replace(bookStartRegex, '$1($2');

            // 5. 단일 별표 문자('*') 제거 (강조된 별표(**) 보존)
            let cleanedText = rawText.replace(/\*\*/g, '@@@BOLD_TEMP@@@');
            cleanedText = cleanedText.replace(/\*/g, '');
            rawText = cleanedText.replace(/@@@BOLD_TEMP@@@/g, '**');

            return rawText.trim();
        }
        
        // --- 6. Core Processing & Utility ---

        function processAndAppend() {
            const inputRaw = inputTextarea.value.trim();
            
            if (!inputRaw) {
                return;
            }

            const cleanedRawText = applyCleaningRules(inputRaw);
            let currentOutputRaw = toRawText(editingTarget.innerHTML);
            let newOutputRaw = currentOutputRaw;
            
            if (newOutputRaw.length > 0) {
                newOutputRaw += '\n\n' + cleanedRawText; 
            } else {
                newOutputRaw = cleanedRawText;
            }

            editingTarget.innerHTML = toRenderableHTML(newOutputRaw);
            editingTarget.scrollTop = editingTarget.scrollHeight; 

            inputTextarea.value = '';
            saveState(); 
        }

        function updateCopyButtonStatus(text) {
             if (text.trim().length > 0) {
                copyButton.disabled = false;
            } else {
                copyButton.disabled = true;
            }
        }

        function applyFormat(command) {
            editingTarget.focus();
            document.execCommand(command, false, null);
            saveState(); 
        }

        function applyFormatBlock(tag) {
            editingTarget.focus();
            document.execCommand('formatBlock', false, tag);
            saveState(); 
        }

        function clearAllText() {
            inputTextarea.value = '';
            editingTarget.innerHTML = '';
            saveState(); 
            
            messageSpan.classList.remove('opacity-100');
            messageSpan.classList.add('opacity-0');
            messageSpan.textContent = '';
        }

        function copyToClipboard() {
            const contentDiv = editingTarget;
            
            if (toRawText(contentDiv.innerHTML).trim() === "") {
                return; 
            }
            
            try {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = contentDiv.innerHTML; 
                
                // --- 인라인 스타일 적용 로직 ---
                // italic 관련 태그 (em, i) 제거됨
                const headings = tempDiv.querySelectorAll('h1, h2, h3, strong, u, b');
                headings.forEach(element => {
                    let style = 'font-family: Inter, sans-serif;';
                    const tag = element.tagName;

                    if (RICH_TEXT_STYLES[tag]) {
                        style += RICH_TEXT_STYLES[tag];
                    }
                    element.style.cssText += style;
                });
                // ------------------------------------

                tempDiv.style.position = 'absolute';
                tempDiv.style.left = '-9999px';
                tempDiv.style.width = '0';
                tempDiv.style.height = '0';
                tempDiv.style.overflow = 'hidden';
                tempDiv.setAttribute('contenteditable', 'true'); 
                document.body.appendChild(tempDiv);
                
                const range = document.createRange();
                range.selectNodeContents(tempDiv);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);

                document.execCommand('copy');
                
                selection.removeAllRanges();
                document.body.removeChild(tempDiv);
                
                // 성공 메시지 표시
                messageSpan.textContent = '복사 완료! (iOS/메모장 모두 최적화됨)';
                messageSpan.classList.remove('opacity-0', 'text-red-600');
                messageSpan.classList.add('opacity-100', 'text-green-600');

                setTimeout(() => {
                    messageSpan.classList.remove('opacity-100');
                    messageSpan.classList.add('opacity-0');
                    messageSpan.textContent = '';
                }, 2000);

            } catch (err) {
                console.error('클립보드 복사 실패:', err);
                messageSpan.textContent = '복사 실패: 콘솔 확인';
                messageSpan.classList.remove('opacity-0', 'text-green-600');
                messageSpan.classList.add('opacity-100', 'text-red-600');
            }
        }

        function initializeState() {
            inputTextarea.value = '';
            editingTarget.innerHTML = '';
            historyStack = [''];
            historyIndex = 0;
            updateHistoryButtons();
            updateCopyButtonStatus('');
        }

        // --- 7. 이벤트 리스너 설정 ---

        // WOL 사이트 열기 및 주요 버튼
        openSiteButton.addEventListener('click', () => {
            window.open('https://wol.jw.org/ko/wol/h/r8/lp-ko', 'wol_tab');
        });
        processButton.addEventListener('click', processAndAppend);
        copyButton.addEventListener('click', copyToClipboard);
        clearButton.addEventListener('click', clearAllText); 
        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);

        // 붙여넣기(Paste) 감지 및 자동 처리
        inputTextarea.addEventListener('paste', () => {
            setTimeout(processAndAppend, 50); 
        });
        
        // 출력 텍스트 영역의 내용이 바뀔 때마다 히스토리 저장
        editingTarget.addEventListener('input', saveState);

        // --- 포맷팅 버튼 그룹화 ---
        
        // 구조 포맷 (H1, H2, H3)
        const structureMap = {
            'title-button': '<h1>',
            'heading-button': '<h2>',
            'subheading-button': '<h3>',
        };

        Object.entries(structureMap).forEach(([id, tag]) => {
            document.getElementById(id).addEventListener('click', () => applyFormatBlock(tag));
        });

        // 기본 포맷 (Bold, Underline) - Italic 제거됨
        const basicFormatMap = {
            'bold-button': 'bold',
            'underline-button': 'underline',
        };

        Object.entries(basicFormatMap).forEach(([id, command]) => {
            document.getElementById(id).addEventListener('click', () => applyFormat(command));
        });
        // -------------------------

        // 초기 상태 설정
        initializeState(); 

    </script>
</body>
</html>
