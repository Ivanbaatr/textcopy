<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>공강 필기 도우미</title>
    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 'Inter' 폰트 사용 */
        :root {
            font-family: 'Inter', sans-serif;
        }
        /* contenteditable div를 textarea처럼 보이게 스타일링 */
        #output-text {
            /* 스크롤바 추가를 위해 max-height와 overflow-y 설정 */
            max-height: 400px; /* 최대 높이를 400px로 설정 */
            overflow-y: auto; /* 내용이 넘칠 때 스크롤바 표시 */

            min-height: 200px;
            white-space: pre-wrap; /* 줄 바꿈 유지 */
            word-wrap: break-word;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            transition: all 150ms ease-in-out;
            font-family: monospace; /* 폰트 고정 */
        }
        /* 시각적 포맷팅을 위한 CSS */
        #output-text u {
            text-decoration: underline;
        }
        #output-text strong {
            font-weight: 700; /* Bold */
        }
        #output-text em {
            font-style: italic;
        }
        /* 제목 (Title - H1) 스타일 */
        #output-text h1 {
            font-size: 1.875rem; /* 30px */
            font-weight: 800; /* Extra bold */
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.25rem;
            border-bottom: 2px solid #374151; /* Gray-700 */
        }
        /* 머리말 (Heading - H2) 스타일 */
        #output-text h2 {
            font-size: 1.5rem; /* 24px */
            font-weight: 700; /* Bold */
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
            padding-left: 0.5rem;
            border-left: 4px solid #4f46e5; /* Indigo-600 */
        }
        /* 부머리말 (Subheading - H3) 스타일 */
        #output-text h3 {
            font-size: 1.25rem; /* 20px */
            font-weight: 600; /* Semibold */
            margin-top: 1rem;
            margin-bottom: 0.25rem;
            color: #1f2937; /* Gray-800 */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 flex items-center justify-center">

    <div id="app" class="bg-white p-6 md:p-8 rounded-xl shadow-2xl w-full max-w-lg space-y-6">
        <!-- 제목 크기: text-4xl로 변경하여 가독성 높임 -->
        <h1 class="text-4xl font-extrabold text-gray-900 text-center border-b pb-3 mb-4">
            공강 필기 도우미 (iOS 복사 서식 유지)
        </h1>
        
        <!-- 고정된 규칙 안내 (숨김 유지) -->
        <div class="p-3 bg-red-50 border-l-4 border-red-500 rounded-lg shadow-sm hidden">
            <p class="text-sm font-semibold text-red-700">
                자동 제거 및 치환 규칙 (WOL 성경 텍스트에 최적화):
            </p>
            <ul class="text-sm text-gray-700 list-disc list-inside ml-2 mt-1">
                <li>**연속된 '+'** 문자 제거</li>
                <li>**'신세계역 성경 (연구용)'** 문구를 **')'** 하나로 치환 (주변 공백 정리 및 **치환 후 문자 2개 추가 제거**)</li>
                <li>**"숫자, 공백, 숫자"** 패턴에서 공백 제거 (예: `1, 234` → `1,234`)</li>
                <li>**줄 시작에 오는 성경 책 이름 앞**에 **'('** 삽입</li>
                <li>**단일 별표('*')** 제거 (원치 않는 기울임꼴 변환 방지)</li>
            </ul>
        </div>
        
        <!-- 1. 입력 영역 -->
        <div>
            <!-- WOL 사이트 열기 버튼 (새로 추가) -->
            <button id="open-site-button"
                class="w-full mb-4 px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-200 transform hover:scale-[1.01] active:scale-[0.99]">
                WOL 검색창 열기 (검색 후 내용 복사)
            </button>

            <!-- 라벨 크기: text-sm -> text-base 로 변경 -->
            <label for="input-text" class="block text-base font-medium text-gray-700 mb-2">
                성구 (여기에 붙여넣으세요) - **붙여넣기 시 자동 정리됩니다.**
            </label>
            
            <textarea id="input-text" rows="6" placeholder="워치타워 온라인 라이브러리에서 성구를 복사하여 여기에 붙여 넣으세요."
                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 shadow-inner"></textarea>
            
            <!-- 처리 버튼 (붙여넣기 자동화로 인해 이제 수동 처리 또는 입력 후 처리용) -->
            <button id="process-button"
                class="w-full mt-3 px-6 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition duration-200 transform hover:scale-[1.01] active:scale-[0.99] disabled:bg-green-300 disabled:cursor-not-allowed">
                아래에 추가하기 (수동 처리)
            </button>
        </div>

        <!-- 2. 결과 영역 -->
        <div class="mt-6">
            <!-- 라벨 크기: text-sm -> text-base 로 변경 -->
            <label for="output-text" class="block text-base font-medium text-gray-700 mb-2">
                필기창 (여기에 텍스트를 작성하세요)
            </label>
            
            <!-- 편집기 컨트롤 -->
            <div class="flex flex-wrap space-x-2 mb-2 p-2 bg-gray-100 rounded-lg shadow-inner border border-gray-200">
                <!-- 실행 취소 버튼 (더 큰 화살표 아이콘 사용) -->
                <button id="undo-button" title="실행 취소" disabled
                    class="p-2 rounded-md text-gray-600 hover:bg-gray-200 transition duration-150 disabled:text-gray-400 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-5 h-5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M9 15L3 9m0 0l6-6M3 9h12a6 6 0 010 12h-3"/>
                    </svg>
                </button>
                <!-- 다시 실행 버튼 (더 큰 화살표 아이콘 사용) -->
                <button id="redo-button" title="다시 실행" disabled
                    class="p-2 rounded-md text-gray-600 hover:bg-gray-200 transition duration-150 disabled:text-gray-400 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-5 h-5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15 9l6 6m0 0l-6 6m6-6H9a6 6 0 010-12h3"/>
                    </svg>
                </button>

                <span class="border-l border-gray-300 mx-1"></span>
                
                <!-- 제목, 머리말, 부머리말 버튼 추가 (터치 영역 p-2로 확대) -->
                <button id="title-button" title="제목 (H1)"
                    class="p-2 rounded-md text-gray-600 hover:bg-gray-200 transition duration-150 font-extrabold text-lg">
                    H1
                </button>
                <button id="heading-button" title="머리말 (H2)"
                    class="p-2 rounded-md text-gray-600 hover:bg-gray-200 transition duration-150 font-bold">
                    H2
                </button>
                <button id="subheading-button" title="부머리말 (H3)"
                    class="p-2 rounded-md text-gray-600 hover:bg-gray-200 transition duration-150 font-semibold">
                    H3
                </button>

                <span class="border-l border-gray-300 mx-1"></span>

                <!-- 기본 포맷 버튼 (터치 영역 p-2로 확대) -->
                <button id="bold-button" title="굵게 (**텍스트**)"
                    class="p-2 rounded-md font-bold text-gray-600 hover:bg-gray-200 transition duration-150">
                    B
                </button>
                <button id="italic-button" title="기울임 (*텍스트*)"
                    class="p-2 rounded-md italic text-gray-600 hover:bg-gray-200 transition duration-150">
                    I
                </button>
                <button id="underline-button" title="밑줄 (<u>텍스트</u>)"
                    class="p-2 rounded-md underline text-gray-600 hover:bg-gray-200 transition duration-150 font-semibold">
                    U
                </button>
            </div>
            
            <!-- contenteditable div -->
            <div id="output-text" contenteditable="true" 
                class="w-full border border-gray-300 rounded-lg text-gray-800 transition duration-150 shadow-inner">
            </div>
        </div>

        <!-- 3. 버튼 및 메시지 영역 -->
        <div class="pt-2 space-y-3">
            <div class="flex flex-col sm:flex-row gap-4">
                <!-- 모두 지우기 버튼 -->
                <button id="clear-button"
                    class="w-full sm:flex-1 px-6 py-3 border border-gray-300 bg-gray-50 text-gray-700 font-semibold rounded-full shadow-md hover:bg-gray-100 transition duration-200 transform hover:scale-105 active:scale-95">
                    모두 지우기
                </button>
                <!-- 복사하기 버튼 -->
                <button id="copy-button"
                    class="w-full sm:flex-1 px-6 py-3 bg-indigo-600 text-white font-semibold rounded-full shadow-lg hover:bg-indigo-700 transition duration-200 transform hover:scale-105 active:scale-95 disabled:bg-indigo-300 disabled:cursor-not-allowed">
                    복사하기
                </button>
            </div>
            <span id="message" class="block text-center text-sm font-medium text-green-600 opacity-0 transition duration-300"></span>
        </div>

        <!-- 4. 버전 표시 영역 (새로 추가됨) -->
        <div class="text-right pt-2">
            <span class="text-xs text-gray-400">v1.0.1</span>
        </div>

    </div>

    <script>
        // DOM 요소 참조
        const inputTextarea = document.getElementById('input-text');
        const outputTextarea = document.getElementById('output-text'); // 이제 div
        const copyButton = document.getElementById('copy-button');
        const clearButton = document.getElementById('clear-button'); 
        const processButton = document.getElementById('process-button'); 
        const messageSpan = document.getElementById('message');
        
        // 편집기 컨트롤 버튼 참조
        const undoButton = document.getElementById('undo-button');
        const redoButton = document.getElementById('redo-button');
        const boldButton = document.getElementById('bold-button');
        const italicButton = document.getElementById('italic-button');
        const underlineButton = document.getElementById('underline-button');
        
        // 구조 포맷팅 버튼 참조
        const titleButton = document.getElementById('title-button');
        const headingButton = document.getElementById('heading-button');
        const subheadingButton = document.getElementById('subheading-button');

        // WOL 사이트 열기 버튼 참조
        const openSiteButton = document.getElementById('open-site-button');

        const apiKey = "" 

        // 성경의 책 이름 전체 목록 (정규식 생성을 위해 배열로 저장)
        const BIBLE_BOOKS = [
            '창세기', '출애굽기', '레위기', '민수기', '신명기', '여호수아', '사사기', '룻기', 
            '사무엘상', '사무엘하', '열왕기상', '열왕기하', '역대기상', '역대기하', '에스라', '느헤미야', 
            '에스더', '욥기', '시편', '잠언', '전도서', '솔로몬의 노래', '이사야', '예레미야', '예레미야 애가', 
            '에스겔', '다니엘', '호세아', '요엘', '아모스', '오바댜', '요나', '미가', '나훔', 
            '하박국', '스바냐', '학개', '스가랴', '말라기', '마태복음', '마가복음', '누가복음', 
            '요한복음', '사도행전', '로마서', '고린도 전서', '고린도 후서', '갈라디아서', '에베소서', 
            '빌립보서', '골로새서', '데살로니가 전서', '데살로니가 후서', '디모데 전서', '디모데 후서', 
            '디도서', '빌레몬서', '히브리서', '야고보서', '베드로 전서', '베드로 후서', 
            '요한 1서', '요한 2서', '요한 3서', '유다서', '요한 계시록'
        ].sort((a, b) => b.length - b.length);


        // --- 텍스트 편집기 (Undo/Redo) 상태 관리 ---
        const MAX_HISTORY_SIZE = 50;
        let historyStack = ['']; 
        let historyIndex = 0;
        let isRestoring = false;
        
        const editingTarget = outputTextarea;

        // --- Conversion Functions ---

        /**
         * Raw Text (Markdown: #, ##, **, *)을 HTML (<h1>, <h2>, <strong>, <em>)로 변환합니다.
         * 이 함수는 히스토리 상태를 출력 영역에 렌더링할 때 사용됩니다.
         */
        function toRenderableHTML(rawText) {
            if (!rawText) return '';
            let html = rawText;
            
            // 1. Markdown Headers를 HTML 태그로 변환합니다.
            // g(전역), m(줄 시작/끝 일치) 플래그 사용
            // ^#\s([^\n]+) : 줄 시작의 #, 공백, 그리고 줄 끝까지의 텍스트를 캡처합니다.
            html = html.replace(/^#\s([^\n]+)/gm, '<h1>$1</h1>');
            html = html.replace(/^##\s([^\n]+)/gm, '<h2>$1</h2>');
            html = html.replace(/^###\s([^\n]+)/gm, '<h3>$1</h3>');
            
            // 2. Inline Markdown을 HTML로 변환합니다.
            html = html.replace(/\*\*(.+?)\*\*/gs, '<strong>$1</strong>'); // Bold
            html = html.replace(/\*(.+?)\*/gs, '<em>$1</em>');       // Italic

            // 3. Raw line breaks를 HTML line breaks로 변환합니다. (Header 변환 후 실행)
            html = html.replace(/\n/g, '<br>');
            
            return html;
        }

        /**
         * HTML Content (editor)를 Markdown/Raw Text (#, ##, **, *)로 변환합니다.
         * 이 함수는 히스토리 상태 저장 및 메모장 복사 시 사용됩니다.
         */
        function toRawText(htmlContent) {
            if (!htmlContent) return '';
            let raw = htmlContent;
            
            // 1. 임시 div를 사용하여 HTML 엔티티 등을 처리하고 내부 텍스트를 가져옵니다.
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = raw;
            raw = tempDiv.innerHTML;

            // Normalize line breaks: replace <br> with \n before handling block elements
            raw = raw.replace(/<br[^>]*>/gis, '\n'); 

            // A. Block Element Conversion (H1, H2, H3 to Markdown Headers)
            // \n\n을 추가하여 헤더 앞뒤에 빈 줄을 만들어 가독성을 높입니다.
            // (.*?)는 캡처 그룹 $1 입니다.
            raw = raw.replace(/<h1[^>]*>(.*?)<\/h1>/gis, '\n\n# $1\n\n'); // Title -> # 
            raw = raw.replace(/<h2[^>]*>(.*?)<\/h2>/gis, '\n\n## $1\n\n'); // Heading -> ## 
            raw = raw.replace(/<h3[^>]*>(.*?)<\/h3>/gis, '\n\n### $1\n\n'); // Subheading -> ### 
            
            // B. Inline Element Conversion (Bold, Italic)
            raw = raw.replace(/<strong[^>]*>(.*?)<\/strong>/gis, '**$1**');
            raw = raw.replace(/<b[^>]*>(.*?)<\/b>/gis, '**$1**'); 
            raw = raw.replace(/<em[^>]*>(.*?)<\/em>/gis, '*$1*');
            raw = raw.replace(/<i[^>]*>(.*?)<\/i>/gis, '*$1*'); 

            // C. Line Break and Cleanup
            // P/DIV 태그를 줄바꿈으로 처리합니다.
            raw = raw.replace(/<div[^>]*>(.*?)<\/div>/gis, '$1\n') 
                     .replace(/<p[^>]*>(.*?)<\/p>/gis, '$1\n')
                     // 마지막에 모든 HTML 태그(<u> 포함)를 제거하여 순수 텍스트를 만듭니다.
                     .replace(/<[^>]+>/g, '')  
                     // 빈 줄이 너무 많으면 두 줄 이상을 한 줄로 압축합니다.
                     .replace(/\n\s*\n\s*\n/g, '\n\n') 
                     .trim();
            
            return raw; 
        }

        /**
         * 현재 텍스트 상태를 기록 스택에 저장합니다.
         */
        function saveState() {
            if (isRestoring) return;

            // HTML 컨텐츠를 Raw Text(마크다운 형태)로 변환하여 저장합니다.
            const currentStateRaw = toRawText(editingTarget.innerHTML);
            const lastState = historyStack[historyIndex];

            if (currentStateRaw !== lastState) {
                if (historyIndex < historyStack.length - 1) {
                    historyStack = historyStack.slice(0, historyIndex + 1);
                }

                if (historyStack.length >= MAX_HISTORY_SIZE) {
                    historyStack.shift(); 
                } else {
                    historyIndex++;
                }
                historyStack[historyIndex] = currentStateRaw;
            }
            updateHistoryButtons();
            updateCopyButtonStatus(currentStateRaw);
        }
        
        /**
         * Undo/Redo 버튼의 활성화 상태를 업데이트합니다.
         */
        function updateHistoryButtons() {
            undoButton.disabled = historyIndex === 0;
            redoButton.disabled = historyIndex === historyStack.length - 1;
        }

        /**
         * 이전 상태로 되돌립니다.
         */
        function undo() {
            if (historyIndex > 0) {
                isRestoring = true;
                historyIndex--;
                // 저장된 Raw Text(마크다운)를 HTML로 변환하여 출력 영역에 표시합니다.
                editingTarget.innerHTML = toRenderableHTML(historyStack[historyIndex]);
                isRestoring = false;
                updateHistoryButtons();
                updateCopyButtonStatus(historyStack[historyIndex]);
                // 포커스를 이동하여 커서 위치를 재설정합니다.
                editingTarget.focus();
            }
        }

        /**
         * 다음 상태로 다시 실행합니다.
         */
        function redo() {
            if (historyIndex < historyStack.length - 1) {
                isRestoring = true;
                historyIndex++;
                // 저장된 Raw Text(마크다운)를 HTML로 변환하여 출력 영역에 표시합니다.
                editingTarget.innerHTML = toRenderableHTML(historyStack[historyIndex]);
                isRestoring = false;
                updateHistoryButtons();
                updateCopyButtonStatus(historyStack[historyIndex]);
                // 포커스를 이동하여 커서 위치를 재설정합니다.
                editingTarget.focus();
            }
        }

        // --- Core Cleaning Logic ---

        /**
         * 입력된 Raw Text에 고정된 규칙을 적용하여 정리된 문자열을 반환합니다.
         * @param {string} rawText - 정리할 원본 텍스트
         * @returns {string} 정리된 텍스트
         */
        function applyCleaningRules(rawText) {
            if (!rawText) return '';

            // 1. 연속된 '+' 문자를 제거합니다.
            rawText = rawText.replace(/\++/g, '');
            
            // 2. '신세계역 성경 (연구용)' 문구를 찾아 ')' 하나로 치환하고 주변 공백을 제거하며, 그 뒤의 문자 2개를 제거합니다.
            const phraseToTarget = "신세계역 성경 (연구용)";
            const escapedPhrase = phraseToTarget.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const phraseRegex = new RegExp(`[\\s\\r\\n]*${escapedPhrase}[\\s\\r\\n]*.{0,2}`, 'g');
            rawText = rawText.replace(phraseRegex, ')');

            // 3. 숫자, 쉼표, 공백, 숫자 패턴에서 공백을 제거합니다. (예: 1, 000 -> 1,000)
            rawText = rawText.replace(/(\d+),\s+(\d+)/g, '$1,$2');
            
            const BIBLE_BOOKS_REGEX_STRING = BIBLE_BOOKS.map(name => name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');

            // 4. (개선됨) 줄 바꿈(\n)이나 텍스트 시작(^) 바로 뒤에 성경 책 이름이 오면 그 앞에 '('를 삽입합니다.
            const bookStartRegex = new RegExp(`(^|\\n)(${BIBLE_BOOKS_REGEX_STRING})`, 'g');
            rawText = rawText.replace(bookStartRegex, '$1($2');

            // 5. WOL 텍스트에서 불필요한 단일 별표 문자('*')를 제거하여 원치 않는 기울임꼴 변환을 방지합니다.
            // a) **를 임시 치환하여 보존합니다.
            let cleanedText = rawText.replace(/\*\*/g, '@@@BOLD_TEMP@@@');
            
            // b) 남은 모든 단일 *를 제거합니다.
            cleanedText = cleanedText.replace(/\*/g, '');

            // c) 임시 치환된 @@BOLD_TEMP@@를 다시 **로 복원합니다.
            rawText = cleanedText.replace(/@@@BOLD_TEMP@@@/g, '**');

            return rawText.trim();
        }
        
        // --- Core Processing Function ---

        /**
         * 입력 텍스트를 정리하고 출력 텍스트에 추가하는 핵심 로직입니다.
         */
        function processAndAppend() {
            const inputRaw = inputTextarea.value.trim();
            
            if (!inputRaw) {
                return;
            }

            // 1. 입력 텍스트 정리
            const cleanedRawText = applyCleaningRules(inputRaw);

            // 2. 현재 출력 텍스트 가져오기 (Raw Text 형태)
            let currentOutputRaw = toRawText(editingTarget.innerHTML);
            
            // 3. 정리된 텍스트를 현재 출력 텍스트의 마지막에 추가합니다.
            let newOutputRaw = currentOutputRaw;
            
            // 기존 내용이 있으면 줄바꿈 두 개(\n\n)를 추가하여 빈 줄을 만듭니다.
            if (newOutputRaw.length > 0) {
                newOutputRaw += '\n\n' + cleanedRawText; 
            } else {
                newOutputRaw = cleanedRawText;
            }

            // 4. 출력 영역 업데이트 및 스크롤 (가장 최근 내용이 보이도록 스크롤합니다)
            editingTarget.innerHTML = toRenderableHTML(newOutputRaw);
            editingTarget.scrollTop = editingTarget.scrollHeight; // 맨 아래로 스크롤

            // 5. 입력 영역 지우기
            inputTextarea.value = '';

            // 6. 히스토리 저장
            saveState(); 
        }

        /**
         * 출력 텍스트 상태(Raw Text 기준)에 따라 복사 버튼을 활성화/비활성화합니다.
         */
        function updateCopyButtonStatus(text) {
             // toRawText로 변환된 내용(마크다운 포함)을 기반으로 체크
             if (text.trim().length > 0) {
                copyButton.disabled = false;
            } else {
                copyButton.disabled = true;
            }
        }


        // --- 텍스트 포맷팅 로직 (Output에 적용) ---

        /**
         * 출력 텍스트 영역의 선택된 텍스트에 포맷을 적용합니다 (execCommand 사용).
         */
        function applyFormat(command) {
            editingTarget.focus();
            document.execCommand(command, false, null);
            saveState(); 
        }

        /**
         * 출력 텍스트 영역의 선택된 텍스트에 블록 포맷(제목, 머리말 등)을 적용합니다.
         */
        function applyFormatBlock(tag) {
            editingTarget.focus();
            // formatBlock 명령어 사용: 선택된 텍스트를 지정된 블록 요소(예: <h1>, <h2>, <p>)로 감쌉니다.
            document.execCommand('formatBlock', false, tag);
            saveState(); 
        }

        /**
         * 입력 및 출력 영역의 모든 텍스트를 지우고 상태를 초기화합니다.
         */
        function clearAllText() {
            inputTextarea.value = '';
            // 출력 영역만 비웁니다.
            editingTarget.innerHTML = '';
            
            // 비어있는 상태를 히스토리에 저장하여, Undo 버튼을 누르면 직전 상태로 복구 가능하도록 합니다.
            saveState(); 
            
            // 메시지 숨기기
            messageSpan.classList.remove('opacity-100');
            messageSpan.classList.add('opacity-0');
            messageSpan.textContent = '';
        }

        /**
         * iOS 및 Rich Text 환경을 위해 HTML 서식을 포함하여 복사하는 기능입니다.
         * 이 함수는 복사 전 HTML 요소에 인라인 스타일을 적용하여 서식 유지력을 높입니다.
         */
        function copyToClipboard() {
            const contentDiv = editingTarget;
            
            // 복사할 내용이 없으면 중단 (Raw Text 기준으로 체크)
            if (toRawText(contentDiv.innerHTML).trim() === "") {
                return; 
            }
            
            try {
                // 1. 임시 div 생성 (화면 밖으로 숨김)
                const tempDiv = document.createElement('div');
                // 현재 화면에 보이는 Rich Text (HTML) 내용을 그대로 복사할 div에 넣습니다.
                tempDiv.innerHTML = contentDiv.innerHTML; 
                
                // --- 핵심 수정: 제목/머리말에 인라인 스타일을 적용하여 iOS 앱에서의 서식 유지력을 높입니다. ---
                const headings = tempDiv.querySelectorAll('h1, h2, h3, strong, em, u');
                headings.forEach(element => {
                    // 기본 글꼴 설정을 위한 기본 스타일
                    let style = 'font-family: Inter, sans-serif;';

                    if (element.tagName === 'H1') {
                        // 제목 (H1) 스타일 (30px, 굵기 800)
                        style += 'font-size: 1.875rem; font-weight: 800; line-height: 1.3; margin-top: 1.5rem; margin-bottom: 0.75rem; border-bottom: 2px solid #374151;';
                    } else if (element.tagName === 'H2') {
                        // 머리말 (H2) 스타일 (24px, 굵기 700)
                        style += 'font-size: 1.5rem; font-weight: 700; line-height: 1.4; margin-top: 1.25rem; margin-bottom: 0.5rem; border-left: 4px solid #4f46e5; padding-left: 0.5rem;';
                    } else if (element.tagName === 'H3') {
                        // 부머리말 (H3) 스타일 (20px, 굵기 600)
                        style += 'font-size: 1.25rem; font-weight: 600; line-height: 1.5; margin-top: 1rem; margin-bottom: 0.25rem; color: #1f2937;';
                    } else if (element.tagName === 'STRONG' || element.tagName === 'B') {
                        // 굵게
                        style += 'font-weight: bold;';
                    } else if (element.tagName === 'EM' || element.tagName === 'I') {
                        // 기울임
                        style += 'font-style: italic;';
                    } else if (element.tagName === 'U') {
                        // 밑줄
                        style += 'text-decoration: underline;';
                    }

                    // 스타일을 기존 스타일과 병합 (만약 있다면)
                    element.style.cssText += style;
                });
                // ----------------------------------------------------------------------


                // Rich Text 복사를 위해 스타일 적용 및 contenteditable 설정
                tempDiv.style.position = 'absolute';
                tempDiv.style.left = '-9999px';
                tempDiv.style.width = '0';
                tempDiv.style.height = '0';
                tempDiv.style.overflow = 'hidden';
                tempDiv.setAttribute('contenteditable', 'true'); 
                document.body.appendChild(tempDiv);
                
                // 2. 임시 div 내용 전체 선택
                const range = document.createRange();
                range.selectNodeContents(tempDiv);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);

                // 3. 복사 실행 (클립보드에 Plain Text와 Rich Text 모두 복사됨)
                document.execCommand('copy');
                
                // 4. 정리
                selection.removeAllRanges();
                document.body.removeChild(tempDiv);
                
                // 성공 메시지 표시
                messageSpan.textContent = '복사 완료! (iOS/메모장 모두 최적화됨)';
                messageSpan.classList.remove('opacity-0', 'text-red-600');
                messageSpan.classList.add('opacity-100', 'text-green-600');

                setTimeout(() => {
                    messageSpan.classList.remove('opacity-100');
                    messageSpan.classList.add('opacity-0');
                    messageSpan.textContent = '';
                }, 2000);

            } catch (err) {
                console.error('클립보드 복사 실패:', err);
                messageSpan.textContent = '복사 실패: 콘솔 확인';
                messageSpan.classList.remove('opacity-0', 'text-green-600');
                messageSpan.classList.add('opacity-100', 'text-red-600');
            }
        }

        /**
         * 애플리케이션의 초기 상태를 설정합니다.
         */
        function initializeState() {
            inputTextarea.value = '';
            editingTarget.innerHTML = '';
            historyStack = [''];
            historyIndex = 0;
            updateHistoryButtons();
            updateCopyButtonStatus('');
        }

        // --- 이벤트 리스너 설정 ---

        // "WOL 성경 사이트 열기" 버튼에 핸들러 연결
        openSiteButton.addEventListener('click', () => {
            window.open('https://wol.jw.org/ko/wol/h/r8/lp-ko', 'wol_tab');
        });
        
        // "아래에 추가하기" 버튼에 핸들러 연결
        processButton.addEventListener('click', processAndAppend);

        // --- 붙여넣기(Paste) 감지 및 자동 처리 ---
        inputTextarea.addEventListener('paste', () => {
            setTimeout(() => {
                processAndAppend();
            }, 50); // 50ms 지연
        });
        
        // 출력 텍스트 영역의 내용이 바뀔 때마다 히스토리와 버튼 상태를 업데이트합니다.
        editingTarget.addEventListener('input', saveState);
        
        // 버튼 클릭 이벤트 연결
        copyButton.addEventListener('click', copyToClipboard);
        clearButton.addEventListener('click', clearAllText); 
        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);

        // 기본 포맷 버튼
        boldButton.addEventListener('click', () => applyFormat('bold'));
        italicButton.addEventListener('click', () => applyFormat('italic'));
        underlineButton.addEventListener('click', () => applyFormat('underline'));

        // 구조 포맷 버튼
        titleButton.addEventListener('click', () => applyFormatBlock('<h1>'));
        headingButton.addEventListener('click', () => applyFormatBlock('<h2>'));
        subheadingButton.addEventListener('click', () => applyFormatBlock('<h3>'));

        // 초기 상태 설정
        initializeState(); 

    </script>
</body>
</html>
